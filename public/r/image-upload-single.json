{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "image-upload-single",
  "type": "registry:component",
  "title": "Image Upload Single",
  "description": "Single Image Upload component with preview and clear functionality.",
  "dependencies": [
    "react",
    "cloudinary",
    "sonner",
    "lucide-react"
  ],
  "registryDependencies": [
    "card",
    "button"
  ],
  "files": [
    {
      "path": "registry//default/starter-kit-ui/image-upload-single.tsx",
      "content": "\"use client\";\r\n\r\nimport { useState } from \"react\";\r\nimport { ImageInput } from \"./image-input\";\r\n\r\nconst ImageUploadSingle = () => {\r\n  const [imageUrl, setImageUrl] = useState(\"\");\r\n\r\n  return (\r\n    <div className=\"flex flex-col gap-3\">\r\n      <ImageInput\r\n        value={imageUrl}\r\n        onChange={(url) => {\r\n          setImageUrl(url); // ðŸ‘ˆ jaise hi file upload hoga, Cloudinary URL aa jayega\r\n        }}\r\n      />\r\n\r\n      {imageUrl && (\r\n        <p className=\"text-sm text-gray-600\">\r\n          âœ… Uploaded Image:{\" \"}\r\n          <a\r\n            href={imageUrl}\r\n            target=\"_blank\"\r\n            className=\"text-violet-600 underline\"\r\n          >\r\n            {imageUrl}\r\n          </a>\r\n        </p>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ImageUploadSingle;\r\n",
      "type": "registry:component"
    },
    {
      "path": "registry/.././app/api/upload/route.ts",
      "content": "// app/api/upload/route.ts\r\nimport { v2 as cloudinary } from \"cloudinary\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\ncloudinary.config({\r\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n  api_key: process.env.CLOUDINARY_API_KEY,\r\n  api_secret: process.env.CLOUDINARY_API_SECRET,\r\n});\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const formData = await req.formData();\r\n    \r\n    // Check if it's single file or multiple files\r\n    const singleFile = formData.get(\"file\") as File;\r\n    const multipleFiles = formData.getAll(\"files\") as File[];\r\n    \r\n    let filesToUpload: File[] = [];\r\n    \r\n    if (multipleFiles.length > 0 && multipleFiles[0] instanceof File) {\r\n      // Multiple files upload\r\n      filesToUpload = multipleFiles.filter(file => file instanceof File);\r\n    } else if (singleFile instanceof File) {\r\n      // Single file upload\r\n      filesToUpload = [singleFile];\r\n    } else {\r\n      return NextResponse.json({ error: \"No valid files received\" }, { status: 400 });\r\n    }\r\n\r\n    if (filesToUpload.length === 0) {\r\n      return NextResponse.json({ error: \"No files to upload\" }, { status: 400 });\r\n    }\r\n\r\n    // Old image URL for cleanup (single file case)\r\n    const oldImageUrl = formData.get(\"oldImageUrl\") as string;\r\n\r\n    // Upload all files to Cloudinary\r\n    const uploadResults = await Promise.all(\r\n      filesToUpload.map(async (file) => {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const base64 = buffer.toString(\"base64\");\r\n        const dataUri = `data:${file.type};base64,${base64}`;\r\n\r\n        const result = await cloudinary.uploader.upload(dataUri, {\r\n          folder: \"uploads\",\r\n          resource_type: \"auto\"\r\n        });\r\n\r\n        return {\r\n          url: result.secure_url,\r\n          publicId: result.public_id,\r\n          originalFilename: file.name,\r\n          size: file.size\r\n        };\r\n      })\r\n    );\r\n\r\n    // Cleanup old image if provided (for single file updates)\r\n    if (oldImageUrl && oldImageUrl.includes(\"cloudinary.com\")) {\r\n      try {\r\n        const publicId = oldImageUrl.split('/').pop()?.split('.')[0];\r\n        if (publicId) {\r\n          await cloudinary.uploader.destroy(publicId);\r\n        }\r\n      } catch (cleanupError) {\r\n        console.error(\"Error cleaning up old image:\", cleanupError);\r\n        // Don't fail the upload if cleanup fails\r\n      }\r\n    }\r\n\r\n    // Return response based on upload type\r\n    if (filesToUpload.length === 1) {\r\n      // Single file - return { url } for backward compatibility\r\n      return NextResponse.json({ \r\n        url: uploadResults[0].url \r\n      });\r\n    } else {\r\n      // Multiple files - return { uploads: [...] }\r\n      return NextResponse.json({ \r\n        uploads: uploadResults \r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(\"Error uploading image(s):\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to upload image(s)\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// DELETE endpoint (same as before)\r\nexport async function DELETE(req: Request) {\r\n  try {\r\n    const { imageUrl } = await req.json();\r\n\r\n    if (!imageUrl || !imageUrl.includes(\"cloudinary.com\")) {\r\n      return NextResponse.json({ error: \"Invalid image URL\" }, { status: 400 });\r\n    }\r\n\r\n    // Extract public ID from Cloudinary URL\r\n    const publicId = imageUrl.split('/').pop()?.split('.')[0];\r\n    \r\n    if (!publicId) {\r\n      return NextResponse.json({ error: \"Invalid Cloudinary URL\" }, { status: 400 });\r\n    }\r\n\r\n    const result = await cloudinary.uploader.destroy(publicId);\r\n\r\n    if (result.result === \"ok\") {\r\n      return NextResponse.json({ success: true });\r\n    } else {\r\n      return NextResponse.json({ error: \"Failed to delete image\" }, { status: 500 });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error deleting image:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to delete image\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}",
      "type": "registry:component"
    },
    {
      "path": "registry/.././app/api/images/route.ts",
      "content": "// app/api/admin/images/route.ts\r\nimport { v2 as cloudinary } from \"cloudinary\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\ncloudinary.config({\r\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n  api_key: process.env.CLOUDINARY_API_KEY,\r\n  api_secret: process.env.CLOUDINARY_API_SECRET,\r\n});\r\n\r\nexport async function GET() {\r\n  try {\r\n    const [images, videos] = await Promise.all([\r\n      cloudinary.api.resources({\r\n        type: \"upload\",\r\n        resource_type: \"image\",\r\n        max_results: 500,\r\n      }),\r\n      cloudinary.api.resources({\r\n        type: \"upload\",\r\n        resource_type: \"video\",\r\n        max_results: 500,\r\n      }),\r\n    ]);\r\n\r\n    // merge both\r\n    const resources = [...images.resources, ...videos.resources];\r\n\r\n    return NextResponse.json({ images: resources });\r\n  } catch (error) {\r\n    console.error(\"Error fetching media:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to fetch media\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// app/api/admin/images/route.ts\r\nexport async function DELETE(req: Request) {\r\n  try {\r\n    const { publicId } = await req.json();\r\n\r\n    const result = await cloudinary.uploader.destroy(publicId);\r\n\r\n    return NextResponse.json(result);\r\n  } catch (error) {\r\n    console.error(\"Error deleting image:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to delete image\" },\r\n      { status: 500 },\r\n    );\r\n  }\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}