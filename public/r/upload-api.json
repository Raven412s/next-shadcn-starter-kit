{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "upload-api",
  "type": "registry:lib",
  "title": "Upload API",
  "description": "Cloudinary upload API routes",
  "dependencies": [
    "cloudinary"
  ],
  "files": [
    {
      "path": "registry/.././app/api/upload/route.ts",
      "content": "// app/api/upload/route.ts\r\nimport { v2 as cloudinary } from \"cloudinary\";\r\nimport { NextResponse } from \"next/server\";\r\n\r\ncloudinary.config({\r\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n  api_key: process.env.CLOUDINARY_API_KEY,\r\n  api_secret: process.env.CLOUDINARY_API_SECRET,\r\n});\r\n\r\nexport async function POST(req: Request) {\r\n  try {\r\n    const formData = await req.formData();\r\n    \r\n    // Check if it's single file or multiple files\r\n    const singleFile = formData.get(\"file\") as File;\r\n    const multipleFiles = formData.getAll(\"files\") as File[];\r\n    \r\n    let filesToUpload: File[] = [];\r\n    \r\n    if (multipleFiles.length > 0 && multipleFiles[0] instanceof File) {\r\n      // Multiple files upload\r\n      filesToUpload = multipleFiles.filter(file => file instanceof File);\r\n    } else if (singleFile instanceof File) {\r\n      // Single file upload\r\n      filesToUpload = [singleFile];\r\n    } else {\r\n      return NextResponse.json({ error: \"No valid files received\" }, { status: 400 });\r\n    }\r\n\r\n    if (filesToUpload.length === 0) {\r\n      return NextResponse.json({ error: \"No files to upload\" }, { status: 400 });\r\n    }\r\n\r\n    // Old image URL for cleanup (single file case)\r\n    const oldImageUrl = formData.get(\"oldImageUrl\") as string;\r\n\r\n    // Upload all files to Cloudinary\r\n    const uploadResults = await Promise.all(\r\n      filesToUpload.map(async (file) => {\r\n        const bytes = await file.arrayBuffer();\r\n        const buffer = Buffer.from(bytes);\r\n        const base64 = buffer.toString(\"base64\");\r\n        const dataUri = `data:${file.type};base64,${base64}`;\r\n\r\n        const result = await cloudinary.uploader.upload(dataUri, {\r\n          folder: \"uploads\",\r\n          resource_type: \"auto\"\r\n        });\r\n\r\n        return {\r\n          url: result.secure_url,\r\n          publicId: result.public_id,\r\n          originalFilename: file.name,\r\n          size: file.size\r\n        };\r\n      })\r\n    );\r\n\r\n    // Cleanup old image if provided (for single file updates)\r\n    if (oldImageUrl && oldImageUrl.includes(\"cloudinary.com\")) {\r\n      try {\r\n        const publicId = oldImageUrl.split('/').pop()?.split('.')[0];\r\n        if (publicId) {\r\n          await cloudinary.uploader.destroy(publicId);\r\n        }\r\n      } catch (cleanupError) {\r\n        console.error(\"Error cleaning up old image:\", cleanupError);\r\n        // Don't fail the upload if cleanup fails\r\n      }\r\n    }\r\n\r\n    // Return response based on upload type\r\n    if (filesToUpload.length === 1) {\r\n      // Single file - return { url } for backward compatibility\r\n      return NextResponse.json({ \r\n        url: uploadResults[0].url \r\n      });\r\n    } else {\r\n      // Multiple files - return { uploads: [...] }\r\n      return NextResponse.json({ \r\n        uploads: uploadResults \r\n      });\r\n    }\r\n\r\n  } catch (error) {\r\n    console.error(\"Error uploading image(s):\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to upload image(s)\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n\r\n// DELETE endpoint (same as before)\r\nexport async function DELETE(req: Request) {\r\n  try {\r\n    const { imageUrl } = await req.json();\r\n\r\n    if (!imageUrl || !imageUrl.includes(\"cloudinary.com\")) {\r\n      return NextResponse.json({ error: \"Invalid image URL\" }, { status: 400 });\r\n    }\r\n\r\n    // Extract public ID from Cloudinary URL\r\n    const publicId = imageUrl.split('/').pop()?.split('.')[0];\r\n    \r\n    if (!publicId) {\r\n      return NextResponse.json({ error: \"Invalid Cloudinary URL\" }, { status: 400 });\r\n    }\r\n\r\n    const result = await cloudinary.uploader.destroy(publicId);\r\n\r\n    if (result.result === \"ok\") {\r\n      return NextResponse.json({ success: true });\r\n    } else {\r\n      return NextResponse.json({ error: \"Failed to delete image\" }, { status: 500 });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error deleting image:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Failed to delete image\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}",
      "type": "registry:lib"
    }
  ]
}