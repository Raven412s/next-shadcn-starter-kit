import { promises as fs } from "node:fs";
import path from "node:path";
import { rimraf } from "rimraf";
import { type Registry, registrySchema } from "shadcn/registry";

import { registry } from "../registry/index";


const REGISTRY_PATH = path.join(process.cwd(), "__registry__");
const REGISTRY_FILENAME = "registry.autogenerated.json";

const parseContent = (content: string) =>
  content
    .replace(/\\/g, '\\\\')
    .replace(/`/g, '\\`')
    .replace(/\${/g, '\\${')
    .replace(/\n/g, '\\n')
    .trim();

const buildRegistry = async (registry: Registry) => {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.

import * as React from "react";

export const Index: Record<string, any> ={`;

  for (const item of registry.items) {
    console.log(`Adding ${item.name} to registry...`);
    if (!Array.isArray(item.files) || !item.files?.length) {
      continue;
    }

    // Fix path for component import
    const componentPath = `@/registry/${item.files[0].path}`;
    const sourcePath = path.join(
      process.cwd(),
      'registry', // Remove 'src/' since you don't have src folder
      item.files[0].path,
    );

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description?.replace(/"/g, '\\"') ?? ''}",
    type: "${item.type}",
    files: [${await Promise.all(
      item.files.map(async (file) => {
        const filePath = `registry/${file.path}`; // Remove 'src/' prefix
        const content = await fs.readFile(path.join(process.cwd(), filePath), 'utf-8');
        
        // Better content escaping
        const escapedContent = content
          .replace(/\\/g, '\\\\')  // Escape backslashes first
          .replace(/`/g, '\\`')    // Escape backticks
          .replace(/\${/g, '\\${') // Escape template literals
          .replace(/"/g, '\\"')    // Escape double quotes
          .replace(/\n/g, '\\n')   // Escape newlines
          .replace(/\r/g, '\\r')   // Escape carriage returns
          .replace(/\t/g, '\\t')   // Escape tabs
          .trim();

        return `{
      path: "${filePath}",
      content: "${escapedContent}",
      type: "${file.type}",
    }`;
      }),
    )}],${
      item.type === 'registry:example'
        ? `
    component: React.lazy(() => import("${componentPath}")),
    source: "${parseContent(await fs.readFile(sourcePath, 'utf-8'))}",`
        : ''
    }
  },`;
  }

  index += '\n}';

  // Update registry JSON path handling
  const registryJSON = JSON.stringify(
    {
      $schema: 'https://ui.shadcn.com/schema/registry.json',
      name: registry.name,
      homepage: registry.homepage,
      items: registry.items
        .filter((item) => item.type !== 'registry:example')
        .map((item) => ({
          ...item,
          files:
            item.files?.map((file) => {
              // Remove 'src/' prefix since you don't have src folder
              if (file.path.startsWith('registry/')) {
                return file;
              }
              return {
                ...file,
                path: `registry/${file.path}`,
              };
            }) ?? [],
        })),
    },
    null,
    2,
  );

  rimraf.sync(path.join(REGISTRY_PATH, REGISTRY_FILENAME));
  await fs.writeFile(
    path.join(REGISTRY_PATH, REGISTRY_FILENAME),
    registryJSON,
    'utf8',
  );

  // Build index.tsx
  rimraf.sync(path.join(REGISTRY_PATH, 'index.tsx'));
  await fs.writeFile(path.join(REGISTRY_PATH, 'index.tsx'), index);
};

try {
  console.log("Building registry...");
  const result = registrySchema.safeParse(registry);
  if (!result.success) {
    console.error("Invalid registry schema:", result.error.format());
    process.exit(1);
  }

  await buildRegistry(result.data);
  console.log("Registry built successfully.");
} catch (error) {
  console.error("Error building registry:", error);
  process.exit(1);
}
